"""
gaitrite_module.py

Reusable GaitRite visualization utilities.

Provides:
- GaitRiteViewer(QtWidgets.QWidget): a PyQt widget using pyqtgraph to display GaitRite footprints and trajectory.
- plot_gaitrite_static(df, gait_id=None, out_path=None, verbose=False): static matplotlib PNG renderer for non-GUI usage.

Expected DataFrame columns:
- Ybottom, Ytop, Xback, Xfront, Foot (0=left, 1=right)
- optional: Gait_Id, Event, Yarray

RectÃ¡ngulos: x = Ybottom * 1.27, y = Xback * 1.27,
           width = (Ytop - Ybottom) * 1.27, height = (Xfront - Xback) * 1.27
Trayectoria: x = ((Ybottom + Ytop)/2)*1.27, y = ((Xback + Xfront)/2)*1.27

The module will attempt to import CARPET_WIDTH_CM and CARPET_LENGTH_CM from a project utils module; if not found, sensible defaults are used.

Author: Generated by GitHub Copilot
"""

from pathlib import Path
from typing import Union, Optional, Tuple
import numpy as np
import pandas as pd

# Try to import PyQt5 or PySide2
try:
    from PyQt5 import QtWidgets, QtCore
    QT = 'pyqt5'
except Exception:
    try:
        from PySide2 import QtWidgets, QtCore
        QT = 'pyside2'
    except Exception:
        QtWidgets = None
        QtCore = None
        QT = None

# Try to import pyqtgraph
try:
    import pyqtgraph as pg
    HAS_PQG = True
except Exception:
    pg = None
    HAS_PQG = False

# Matplotlib fallback for static plotting
try:
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    from matplotlib.patches import Polygon, Rectangle
    HAS_MPL = True
except Exception:
    HAS_MPL = False

# Try to import carpet sizes from project utils (many projects define these). Use fallbacks.
try:
    # attempt relative/absolute imports
    from .utils import CARPET_WIDTH_CM, CARPET_LENGTH_CM  # type: ignore
except Exception:
    try:
        from utils import CARPET_WIDTH_CM, CARPET_LENGTH_CM  # type: ignore
    except Exception:
        CARPET_WIDTH_CM = 61.0    # fallback width (cm)
        CARPET_LENGTH_CM = 488.0  # fallback length (cm)

CONVERSION_FACTOR = 1.27


def _robust_minmax(vals: np.ndarray) -> Tuple[float, float]:
    """Return (p1, p99) or min/max fallback. Avoid collapse."""
    if vals.size == 0:
        return 0.0, 1.0
    p1, p99 = np.percentile(vals, [1, 99])
    if not np.isfinite(p1) or not np.isfinite(p99) or p99 <= p1:
        p1, p99 = float(np.min(vals)), float(np.max(vals))
    if p99 == p1:
        p99 = p1 + 1e-9
    return float(p1), float(p99)


def decode_yarray_to_xy(yarray_raw: str, Xback_cm: float, Xfront_cm: float, Ybottom_cm: float, Ytop_cm: float, verbose: bool = False) -> Optional[pd.DataFrame]:
    """
    Decode a Yarray string into a DataFrame with sample_idx, x_cm, y_cm.

    Steps:
    - convert characters to ord()
    - normalize by percentiles 1 and 99 (fallback to min/max)
    - map normalized values to [Ybottom_cm, Ytop_cm] (x direction)
    - y is linear between Xback_cm and Xfront_cm
    """
    try:
        if not isinstance(yarray_raw, str) or len(yarray_raw) == 0:
            return None
        vals = np.fromiter((ord(c) for c in yarray_raw), dtype=float, count=len(yarray_raw))
        if vals.size == 0 or not np.isfinite(vals).all():
            return None
        lo, hi = _robust_minmax(vals)
        vals_norm = (vals - lo) / (hi - lo)
        dx = (Ytop_cm - Ybottom_cm)
        dy = (Xfront_cm - Xback_cm)
        if abs(dx) < 1e-9 or abs(dy) < 1e-9:
            return None
        x_cm = Ybottom_cm + vals_norm * dx
        N = vals.shape[0]
        y_cm = np.linspace(Xback_cm, Xfront_cm, N)
        df = pd.DataFrame({
            'sample_idx': np.arange(N, dtype=int),
            'x_cm': x_cm.astype(float),
            'y_cm': y_cm.astype(float),
        })
        if verbose:
            print(f"DEBUG decode_yarray: N={N}, x_cm[{0:.3f}..{ -1 if N>1 else 0 }]" )
        return df
    except Exception as e:
        if verbose:
            print(f"DEBUG decode_yarray error: {e}")
        return None


class GaitRiteViewerBase:
    """
    Base implementation independent of the specific Qt binding.
    This class groups shared logic so tests can use it without constructing a QWidget.
    """

    def __init__(self, verbose: bool = False):
        self.gaitrite_tests_df: Optional[pd.DataFrame] = None
        self.current_participant = None
        self.current_prueba = None
        self.current_intento = None
        self.sequential_to_gait_id = {}
        self.gait_id_to_sequential = {}
        self.verbose = verbose

    def load_data(self, source: Union[pd.DataFrame, str, Path]):
        """
        Load data from a DataFrame or a path.
        If source is a folder, looks for gaitrite_test.csv inside. If a CSV path, loads it directly.
        Stores DataFrame in self.gaitrite_tests_df.
        """
        try:
            if isinstance(source, pd.DataFrame):
                self.gaitrite_tests_df = source.copy()
                if self.verbose:
                    print(f"DEBUG: DataFrame loaded with {len(self.gaitrite_tests_df)} rows")
                return

            p = Path(source)
            if p.is_dir():
                file_candidate = p / 'gaitrite_test.csv'
                if not file_candidate.exists():
                    file_candidate = p / 'gaitrite_tests.csv'
                if not file_candidate.exists():
                    # try in root
                    file_candidate = Path('gaitrite_test.csv')
                csv_path = file_candidate
            else:
                csv_path = p

            if not csv_path.exists():
                if self.verbose:
                    print(f"DEBUG: gaitrite CSV not found at {csv_path}")
                self.gaitrite_tests_df = None
                return

            # Try reading with ; first then fallback
            try:
                df = pd.read_csv(csv_path)
            except Exception:
                df = pd.read_csv(csv_path, delimiter=';')
            self.gaitrite_tests_df = df
            if self.verbose:
                print(f"DEBUG: Loaded CSV {csv_path} rows={len(df)} columns={list(df.columns)}")
        except Exception as e:
            if self.verbose:
                print(f"DEBUG load_data error: {e}")
            self.gaitrite_tests_df = None

    def _draw_carpet_data_to_plot(self, plot_callable, show_text: bool = True):
        """
        plot_callable is a function that accepts polygons/lines to draw on the target.
        For pyqtgraph, it will be a wrapper around self.gaitrite_plot.plot/addItem.
        For matplotlib it will add patches to axes.
        """
        # Draw carpet rectangle
        bg_x = [0, CARPET_WIDTH_CM, CARPET_WIDTH_CM, 0]
        bg_y = [0, 0, CARPET_LENGTH_CM, CARPET_LENGTH_CM]
        plot_callable('polygon', bg_x, bg_y, pen_color='gray', brush_color=(240, 240, 240, 0.4))
        if show_text:
            plot_callable('text', CARPET_WIDTH_CM / 2, CARPET_LENGTH_CM / 2,
                          text=f"ðŸš¶ Alfombra GaitRite\n{CARPET_WIDTH_CM} Ã— {CARPET_LENGTH_CM} cm")

    def _plot_rect_on_target(self, plot_callable, x, y, width, height, foot: int):
        color = 'red' if foot == 0 else 'blue'
        # rectangle polygon
        rx = [x, x + width, x + width, x]
        ry = [y, y, y + height, y + height]
        plot_callable('polygon', rx + [rx[0]], ry + [ry[0]], pen_color=color)

    def _plot_traj_on_target(self, plot_callable, x_arr, y_arr):
        plot_callable('line', x_arr, y_arr, pen_color='black')

    def _attempt_draw_contours(self, gait_id, plot_callable) -> bool:
        """
        Try to draw precise contours from CSVs (generated_footprints_left/right or footprints_left/right)
        or from Yarray. Returns True if any contour was drawn.
        """
        drew = False
        try:
            # try to find footprint CSVs in current intent folder
            if self.current_participant and self.current_prueba and self.current_intento:
                intent_path = Path('data') / self.current_participant / self.current_prueba / self.current_intento
            else:
                intent_path = Path('.')

            left_candidates = [intent_path / 'footprints_left.csv', intent_path / 'generated_footprints_left.csv']
            right_candidates = [intent_path / 'footprints_right.csv', intent_path / 'generated_footprints_right.csv']

            left_df = None
            right_df = None
            for c in left_candidates:
                if c.exists():
                    try:
                        left_df = pd.read_csv(c)
                        if self.verbose:
                            print(f"DEBUG: loaded {c}")
                        break
                    except Exception:
                        left_df = pd.read_csv(c, delimiter=';')
                        break
            for c in right_candidates:
                if c.exists():
                    try:
                        right_df = pd.read_csv(c)
                        if self.verbose:
                            print(f"DEBUG: loaded {c}")
                        break
                    except Exception:
                        right_df = pd.read_csv(c, delimiter=';')
                        break

            # If footprints CSVs available, draw polylines grouped by event
            for df, foot_val in ((left_df, 0), (right_df, 1)):
                if df is None or df.empty:
                    continue
                if 'gait_id' in df.columns:
                    df_g = df[df['gait_id'] == gait_id]
                else:
                    df_g = df
                if df_g.empty:
                    continue
                # group by event if exists
                grp_col = 'event' if 'event' in df_g.columns else None
                if grp_col:
                    groups = df_g.groupby(grp_col)
                else:
                    groups = [(None, df_g)]
                for ev, grp in groups:
                    grp_sorted = grp.sort_values('sample_idx') if 'sample_idx' in grp.columns else grp
                    if 'x_cm' in grp_sorted.columns and 'y_cm' in grp_sorted.columns:
                        x = grp_sorted['x_cm'].values
                        y = grp_sorted['y_cm'].values
                        plot_callable('polyline', x, y, pen_color=('red' if foot_val == 0 else 'blue'))
                        drew = True
            # If none, try generate from Yarray
            if not drew and self.gaitrite_tests_df is not None and 'Yarray' in self.gaitrite_tests_df.columns:
                # filter by gait_id
                if 'Gait_Id' in self.gaitrite_tests_df.columns:
                    df_filtered = self.gaitrite_tests_df[self.gaitrite_tests_df['Gait_Id'] == gait_id]
                else:
                    df_filtered = self.gaitrite_tests_df
                for _, r in df_filtered.iterrows():
                    try:
                        foot = int(r['Foot']) if pd.notna(r['Foot']) else None
                    except Exception:
                        foot = None
                    if foot not in (0, 1):
                        continue
                    try:
                        Xback_cm = float(r['Xback']) * CONVERSION_FACTOR
                        Xfront_cm = float(r['Xfront']) * CONVERSION_FACTOR
                        Ybottom_cm = float(r['Ybottom']) * CONVERSION_FACTOR
                        Ytop_cm = float(r['Ytop']) * CONVERSION_FACTOR
                    except Exception:
                        continue
                    yarray_raw = str(r['Yarray']) if pd.notna(r['Yarray']) else ''
                    df_xy = decode_yarray_to_xy(yarray_raw, Xback_cm, Xfront_cm, Ybottom_cm, Ytop_cm, verbose=self.verbose)
                    if df_xy is None:
                        continue
                    plot_callable('polyline', df_xy['x_cm'].values, df_xy['y_cm'].values, pen_color=('red' if foot == 0 else 'blue'))
                    drew = True
        except Exception as e:
            if self.verbose:
                print(f"DEBUG attempt_draw_contours error: {e}")
        return drew


# If GUI available, implement QWidget class
if QtWidgets is not None and HAS_PQG:
    class GaitRiteViewer(QtWidgets.QWidget, GaitRiteViewerBase):
        """PyQt widget implementing GaitRite visualization with pyqtgraph."""
        def __init__(self, parent=None, verbose: bool = False):
            QtWidgets.QWidget.__init__(self, parent)
            GaitRiteViewerBase.__init__(self, verbose=verbose)
            self.init_ui()

        def init_ui(self):
            layout = QtWidgets.QVBoxLayout(self)
            title = QtWidgets.QLabel("ðŸš¶ GaitRite Analysis")
            title.setAlignment(QtCore.Qt.AlignCenter)
            layout.addWidget(title)
            self.gaitrite_plot = pg.PlotWidget()
            self.gaitrite_plot.setBackground('white')
            self.gaitrite_plot.setMinimumSize(400, 700)
            self.gaitrite_plot.setMouseEnabled(x=False, y=False)
            self.gaitrite_plot.setMenuEnabled(False)
            self.gaitrite_plot.hideButtons()
            plot_item = self.gaitrite_plot.getPlotItem()
            plot_item.setLabel('left', 'Longitud (cm)')
            plot_item.setLabel('bottom', 'Ancho (cm)')
            plot_item.showGrid(True, True, alpha=0.3)
            layout.addWidget(self.gaitrite_plot)
            legend = QtWidgets.QLabel("ðŸ”´ Pie Izquierdo  ðŸ”µ Pie Derecho  âš« Trayectoria")
            legend.setAlignment(QtCore.Qt.AlignCenter)
            layout.addWidget(legend)
            self.show_empty_plot()

        def show_empty_plot(self):
            self.gaitrite_plot.clear()
            # draw carpet
            self._draw_carpet_pyqtgraph(show_text=True)

        def _draw_carpet_pyqtgraph(self, show_text=True):
            # polygon
            bg_x = [0, CARPET_WIDTH_CM, CARPET_WIDTH_CM, 0]
            bg_y = [0, 0, CARPET_LENGTH_CM, CARPET_LENGTH_CM]
            self.gaitrite_plot.plot(bg_x + [bg_x[0]], bg_y + [bg_y[0]], pen=pg.mkPen('gray', width=2))
            brush = pg.mkBrush(240, 240, 240, 100)
            # fill by creating a QGraphicsPolygonItem via plotCurve? Simpler: add a filled polygon using PlotDataItem with fillLevel
            self.gaitrite_plot.plot(bg_x + [bg_x[0]], bg_y + [bg_y[0]], pen=None, brush=brush, fillLevel=0)
            if show_text:
                txt = pg.TextItem(f"ðŸš¶ Alfombra GaitRite\n{CARPET_WIDTH_CM} Ã— {CARPET_LENGTH_CM} cm",
                                  anchor=(0.5, 0.5), color='#7F8C8D')
                txt.setPos(CARPET_WIDTH_CM / 2, CARPET_LENGTH_CM / 2)
                self.gaitrite_plot.addItem(txt)

        def load_data(self, source: Union[pd.DataFrame, str, Path]):
            return GaitRiteViewerBase.load_data(self, source)

        def visualize_gait_test(self, gait_id: int):
            if self.gaitrite_tests_df is None:
                self.show_empty_plot()
                return
            self.gaitrite_plot.clear()
            self._draw_carpet_pyqtgraph(show_text=False)
            selected = None
            if 'Gait_Id' in self.gaitrite_tests_df.columns:
                selected = self.gaitrite_tests_df[self.gaitrite_tests_df['Gait_Id'] == gait_id]
            else:
                selected = self.gaitrite_tests_df
            if selected is None or selected.empty:
                self.show_empty_plot()
                return
            # try contours
            drew = self._attempt_draw_contours(gait_id, self._pyqt_plot_callable)
            if not drew:
                # fallback rectangles
                for _, row in selected.iterrows():
                    try:
                        x = float(row['Ybottom']) * CONVERSION_FACTOR
                        y = float(row['Xback']) * CONVERSION_FACTOR
                        width = (float(row['Ytop']) - float(row['Ybottom'])) * CONVERSION_FACTOR
                        height = (float(row['Xfront']) - float(row['Xback'])) * CONVERSION_FACTOR
                        if width <= 0 or height <= 0:
                            continue
                        pen = pg.mkPen('red', width=2) if int(row.get('Foot', 0)) == 0 else pg.mkPen('blue', width=2)
                        rx = [x, x + width, x + width, x, x]
                        ry = [y, y, y + height, y + height, y]
                        self.gaitrite_plot.plot(rx, ry, pen=pen)
                    except Exception as e:
                        if self.verbose:
                            print(f"DEBUG rect draw error: {e}")
                        continue
                # trajectory
                try:
                    traj_x = (((selected['Ybottom'] + selected['Ytop']) / 2) * CONVERSION_FACTOR).values
                    traj_y = (((selected['Xback'] + selected['Xfront']) / 2) * CONVERSION_FACTOR).values
                    self.gaitrite_plot.plot(traj_x, traj_y, pen=pg.mkPen('black', width=2))
                except Exception as e:
                    if self.verbose:
                        print(f"DEBUG traj error: {e}")
            # lock view
            self._lock_gaitrite_view()

        def _pyqt_plot_callable(self, kind, x, y=None, pen_color='black', brush_color=None, text=None):
            """Helper converting abstract plot requests to pyqtgraph drawing calls."""
            try:
                if kind == 'polygon' or kind == 'polyline':
                    xs = np.asarray(x)
                    ys = np.asarray(y)
                    pen = pg.mkPen(pen_color, width=2)
                    self.gaitrite_plot.plot(xs, ys, pen=pen)
                elif kind == 'line':
                    xs = np.asarray(x)
                    ys = np.asarray(y)
                    self.gaitrite_plot.plot(xs, ys, pen=pg.mkPen(pen_color, width=2))
                elif kind == 'text':
                    ti = pg.TextItem(text, anchor=(0.5, 0.5), color='#7F8C8D')
                    ti.setPos(x, y)
                    self.gaitrite_plot.addItem(ti)
                else:
                    pass
            except Exception as e:
                if self.verbose:
                    print(f"DEBUG pyqt_plot_callable error: {e}")

        def _lock_gaitrite_view(self):
            try:
                self.gaitrite_plot.disableAutoRange()
                padding_x = CARPET_WIDTH_CM * 0.10
                padding_y = CARPET_LENGTH_CM * 0.08
                self.gaitrite_plot.setXRange(-padding_x, CARPET_WIDTH_CM + padding_x, padding=0)
                self.gaitrite_plot.setYRange(-padding_y, CARPET_LENGTH_CM + padding_y, padding=0)
                self.gaitrite_plot.setLimits(
                    xMin=-padding_x, xMax=CARPET_WIDTH_CM + padding_x,
                    yMin=-padding_y, yMax=CARPET_LENGTH_CM + padding_y
                )
                self.gaitrite_plot.setMouseEnabled(x=False, y=False)
                self.gaitrite_plot.setMenuEnabled(False)
            except Exception as e:
                if self.verbose:
                    print(f"DEBUG lock view error: {e}")

else:
    # If Qt or pyqtgraph not available, provide a placeholder class that keeps same API but does nothing
    class GaitRiteViewer(GaitRiteViewerBase):
        def __init__(self, parent=None, verbose: bool = False):
            super().__init__(verbose=verbose)
            if verbose:
                print("DEBUG: GUI not available; GaitRiteViewer is a headless object")

        def show_empty_plot(self):
            if self.verbose:
                print("DEBUG: show_empty_plot (headless)")

        def load_data(self, source: Union[pd.DataFrame, str, Path]):
            return super().load_data(source)

        def visualize_gait_test(self, gait_id: int):
            if self.verbose:
                print(f"DEBUG: visualize_gait_test({gait_id}) (headless)")

        def visualize_direct_data(self):
            if self.verbose:
                print("DEBUG: visualize_direct_data (headless)")


def plot_gaitrite_figure(df: pd.DataFrame, gait_id: Optional[int] = None, figsize=(6, 10), verbose: bool = False):
    """Create a matplotlib Figure with the GaitRite plot and return it (does not save).

    Useful to embed into GUIs (Tkinter via FigureCanvasTkAgg) without writing PNGs to disk.
    """
    if not HAS_MPL:
        if verbose:
            print("DEBUG: matplotlib not available")
        return None
    try:
        if gait_id is not None and 'Gait_Id' in df.columns:
            selected = df[df['Gait_Id'] == gait_id]
        else:
            selected = df
        fig, ax = plt.subplots(figsize=figsize)
        ax.set_facecolor('#ffffff')
        # draw carpet
        rect = Rectangle((0, 0), CARPET_WIDTH_CM, CARPET_LENGTH_CM, linewidth=1.5, edgecolor='gray', facecolor='#f0f0f0', zorder=0)
        ax.add_patch(rect)
        ax.text(CARPET_WIDTH_CM / 2, CARPET_LENGTH_CM / 2, f"ðŸš¶ Alfombra GaitRite\n{CARPET_WIDTH_CM} Ã— {CARPET_LENGTH_CM} cm", ha='center', va='center', color='#7f8c8d')

        drew = False
        if 'Yarray' in selected.columns:
            for _, r in selected.iterrows():
                try:
                    foot = int(r['Foot']) if pd.notna(r['Foot']) else None
                except Exception:
                    foot = None
                if foot not in (0, 1):
                    continue
                try:
                    Xback_cm = float(r['Xback']) * CONVERSION_FACTOR
                    Xfront_cm = float(r['Xfront']) * CONVERSION_FACTOR
                    Ybottom_cm = float(r['Ybottom']) * CONVERSION_FACTOR
                    Ytop_cm = float(r['Ytop']) * CONVERSION_FACTOR
                except Exception:
                    continue
                df_xy = decode_yarray_to_xy(str(r['Yarray']), Xback_cm, Xfront_cm, Ybottom_cm, Ytop_cm, verbose=verbose)
                if df_xy is None:
                    continue
                poly = Polygon(np.column_stack((df_xy['x_cm'].values, df_xy['y_cm'].values)), closed=False, facecolor='none', edgecolor=('red' if foot == 0 else 'blue'))
                ax.add_patch(poly)
                drew = True

        if not drew:
            for _, row in selected.iterrows():
                try:
                    x = float(row['Ybottom']) * CONVERSION_FACTOR
                    y = float(row['Xback']) * CONVERSION_FACTOR
                    width = (float(row['Ytop']) - float(row['Ybottom'])) * CONVERSION_FACTOR
                    height = (float(row['Xfront']) - float(row['Xback'])) * CONVERSION_FACTOR
                    if width <= 0 or height <= 0:
                        continue
                    rect = Rectangle((x, y), width, height, linewidth=1.5, edgecolor=('red' if int(row.get('Foot', 0)) == 0 else 'blue'), facecolor='none')
                    ax.add_patch(rect)
                except Exception:
                    continue
            try:
                traj_x = (((selected['Ybottom'] + selected['Ytop']) / 2) * CONVERSION_FACTOR).values
                traj_y = (((selected['Xback'] + selected['Xfront']) / 2) * CONVERSION_FACTOR).values
                ax.plot(traj_x, traj_y, linestyle='-', color='#2C3E50', linewidth=1.5)
            except Exception:
                pass

        ax.set_xlim(-CARPET_WIDTH_CM * 0.05, CARPET_WIDTH_CM * 1.05)
        ax.set_ylim(-CARPET_LENGTH_CM * 0.05, CARPET_LENGTH_CM * 1.05)
        ax.set_xlabel('Ancho (cm)')
        ax.set_ylabel('Longitud (cm)')
        ax.set_aspect('equal', adjustable='box')
        plt.tight_layout()
        return fig
    except Exception as e:
        if verbose:
            print(f"DEBUG plot_gaitrite_figure error: {e}")
        return None


def plot_gaitrite_static(df: pd.DataFrame, gait_id: Optional[int] = None, out_path: Optional[Union[str, Path]] = None, verbose: bool = False) -> Optional[Path]:
    """
    Static matplotlib PNG renderer. If out_path provided, saves PNG there and returns Path.
    If gait_id is provided, draws only that test (if Gait_Id exists), otherwise draws whole DataFrame.
    """
    fig = plot_gaitrite_figure(df, gait_id=gait_id, verbose=verbose)
    if fig is None:
        return None
    try:
        if out_path is not None:
            outp = Path(out_path)
            outp.parent.mkdir(parents=True, exist_ok=True)
            fig.savefig(str(outp), dpi=150)
            plt.close(fig)
            if verbose:
                print(f"DEBUG: Saved static plot to {outp}")
            return outp
        else:
            tmp = Path('gaitrite_plot.png')
            fig.savefig(str(tmp), dpi=150)
            plt.close(fig)
            if verbose:
                print(f"DEBUG: Saved static plot to {tmp}")
            return tmp
    except Exception as e:
        if verbose:
            print(f"DEBUG plot_gaitrite_static error: {e}")
        try:
            plt.close(fig)
        except Exception:
            pass
        return None


if __name__ == '__main__':
    # minimal example
    import sys
    sample_csv = Path('P1/FP/1/generated_footprints_left.csv')
    viewer = None
    if QtWidgets is not None and HAS_PQG:
        app = QtWidgets.QApplication(sys.argv)
        v = GaitRiteViewer(verbose=True)
        if sample_csv.exists():
            v.load_data(sample_csv)
        v.show()
        sys.exit(app.exec_())
    else:
        # headless: attempt static plot
        if sample_csv.exists():
            df = pd.read_csv(sample_csv)
            out = plot_gaitrite_static(df, verbose=True)
            print(f"Static output: {out}")
        else:
            print("No GUI available and sample CSV not found.")
